"use strict";(self.webpackChunk_synthql_docs=self.webpackChunk_synthql_docs||[]).push([[741],{6403:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>a,toc:()=>h});var r=n(2322),s=n(5392);const o={},i="Lazy queries",a={id:"lazy-queries",title:"Lazy queries",description:"The bigger the query, the longer the latency",source:"@site/docs/500-lazy-queries.md",sourceDirName:".",slug:"/lazy-queries",permalink:"/synthql/docs/lazy-queries",draft:!1,unlisted:!1,editUrl:"https://github.com/fhur/synthql/tree/master/packages/docs/docs/500-lazy-queries.md",tags:[],version:"current",sidebarPosition:500,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Complex queries",permalink:"/synthql/docs/complex-queries"},next:{title:"Schema changes",permalink:"/synthql/docs/handling-schema-changes"}},l={},h=[{value:"The bigger the query, the longer the latency",id:"the-bigger-the-query-the-longer-the-latency",level:2},{value:"Example: store with many products",id:"example-store-with-many-products",level:2},{value:"What happens over the wire",id:"what-happens-over-the-wire",level:2}];function c(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",p:"p",pre:"pre",...(0,s.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.h1,{id:"lazy-queries",children:"Lazy queries"}),"\n",(0,r.jsx)(t.h2,{id:"the-bigger-the-query-the-longer-the-latency",children:"The bigger the query, the longer the latency"}),"\n",(0,r.jsx)(t.p,{children:"One of the disadvantages of large query trees is that they result in proportionally longer latencies. The reason is simple: you have to wait for the entire query tree to load before you can send the response back to the client. So the bigger the query, the longer the wait."}),"\n",(0,r.jsxs)(t.p,{children:["To mitigate this issue, ",(0,r.jsx)(t.code,{children:"synthql"})," let's you mark parts of your query tree as ",(0,r.jsx)(t.code,{children:"lazy"}),". A lazy boundary will split your query into two and will tell the QueryEngine to flush results to the client in sequences."]}),"\n",(0,r.jsxs)(t.p,{children:["This feature is similar to ",(0,r.jsx)(t.a,{href:"https://graphql.org/blog/2020-12-08-improving-latency-with-defer-and-stream-directives/",children:"graphql's @defer directive"}),"."]}),"\n",(0,r.jsx)(t.h2,{id:"example-store-with-many-products",children:"Example: store with many products"}),"\n",(0,r.jsx)(t.p,{children:"Let's imagine that you have a store that can sell hundreds of different products. You need to implement a Store page in which you display the store's properties and after srolling a bit the user can see a list of all the products sold by the store."}),"\n",(0,r.jsxs)(t.p,{children:["To improve the latency of this page you can mark the ",(0,r.jsx)(t.code,{children:"products"})," query as ",(0,r.jsx)(t.code,{children:".lazy()"})," as follows:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-tsx",children:"const products = from('products')\n    .column('id','price','name')\n    .lazy() // <======= this marks the products query as lazy\n    .many()\n\n\nconst query = from('store')\n    .column('id','store_name','store_owner')\n    .include({\n        products\n    })\n\nuseSynthql(query)\n"})}),"\n",(0,r.jsxs)(t.p,{children:["Marking the ",(0,r.jsx)(t.code,{children:"products"})," subquery as lazy will result in the query client first fetching the ",(0,r.jsx)(t.code,{children:"store"}),", and then re-rendering the component when eventually the data from the ",(0,r.jsx)(t.code,{children:"products"})," comes in."]}),"\n",(0,r.jsx)(t.h2,{id:"what-happens-over-the-wire",children:"What happens over the wire"}),"\n",(0,r.jsxs)(t.p,{children:["When the ",(0,r.jsx)(t.code,{children:"QueryEngine"})," executes a query it will flush results to the client whenever it sees a ",(0,r.jsx)(t.code,{children:"lazy()"})," boundary. In this example this will result in two lines of JSON being sent to the client over the same HTTP connection as follows"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:"// First line of JSON\n{id: '123', 'store_name': 'Fun Inc.', store_owner: 'Bob', products: {status:'pending'}}\n// Once the products have loaded\n{id: '123', 'store_name': 'Toys Inc.', store_owner: 'Bill', products: {status:'done', data: [...]}}\n"})})]})}function d(e={}){const{wrapper:t}={...(0,s.a)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},5392:(e,t,n)=>{n.d(t,{Z:()=>a,a:()=>i});var r=n(2784);const s={},o=r.createContext(s);function i(e){const t=r.useContext(o);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),r.createElement(o.Provider,{value:t},e.children)}}}]);