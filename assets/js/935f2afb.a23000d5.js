"use strict";(self.webpackChunk_synthql_docs=self.webpackChunk_synthql_docs||[]).push([[53],{1109:e=>{e.exports=JSON.parse('{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"noIndex":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"tutorialSidebar":[{"type":"link","label":"Getting started","href":"/synthql/docs/getting-started","docId":"getting-started","unlisted":false},{"type":"link","label":"Security","href":"/synthql/docs/security","docId":"security","unlisted":false},{"type":"link","label":"Query language","href":"/synthql/docs/query-language","docId":"query-language","unlisted":false},{"type":"link","label":"Complex queries","href":"/synthql/docs/complex-queries","docId":"complex-queries","unlisted":false},{"type":"link","label":"Lazy queries","href":"/synthql/docs/lazy-queries","docId":"lazy-queries","unlisted":false},{"type":"link","label":"Schema changes","href":"/synthql/docs/handling-schema-changes","docId":"handling-schema-changes","unlisted":false},{"type":"link","label":"Generating types","href":"/synthql/docs/generating-types","docId":"generating-types","unlisted":false},{"type":"link","label":"Custom Query Executors","href":"/synthql/docs/custom-query-executors","docId":"custom-query-executors","unlisted":false},{"type":"link","label":"Architecture","href":"/synthql/docs/architecture","docId":"architecture","unlisted":false}]},"docs":{"architecture":{"id":"architecture","title":"Architecture","description":"This is a brief, high level guide that documents synthqls architecture.","sidebar":"tutorialSidebar"},"complex-queries":{"id":"complex-queries","title":"Complex queries","description":"Having","sidebar":"tutorialSidebar"},"custom-query-executors":{"id":"custom-query-executors","title":"Custom Query Executors","description":"Although synthql provides great support for fetching data from your database, not all data comes from databases. Custom query executors let you execute parts of a query tree using a custom executor function. This can be used to fetch data from a source other than your database, such as a REST endpoint, a file or any other data source you can imagine.","sidebar":"tutorialSidebar"},"generating-types":{"id":"generating-types","title":"Generating types","description":"To generate a schema, create an instance of the QueryEngine and call the generateSchema function.","sidebar":"tutorialSidebar"},"getting-started":{"id":"getting-started","title":"Getting started","description":"Install the NPM package","sidebar":"tutorialSidebar"},"handling-schema-changes":{"id":"handling-schema-changes","title":"Schema changes","description":"jsonb / json columns","sidebar":"tutorialSidebar"},"lazy-queries":{"id":"lazy-queries","title":"Lazy queries","description":"The bigger the query, the longer the latency","sidebar":"tutorialSidebar"},"query-language":{"id":"query-language","title":"Query language","description":"synthql comes with a very basic query language. Let\'s see a few examples:","sidebar":"tutorialSidebar"},"security":{"id":"security","title":"Security","description":"Letting clients make arbitrary queries, even if read-only comes with a set of security challenges. synthql comes with built in mechanisms to implement robust authorization logic so you can limit what queries clients can make.","sidebar":"tutorialSidebar"}}}')}}]);