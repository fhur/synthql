"use strict";(self.webpackChunk_synthql_docs=self.webpackChunk_synthql_docs||[]).push([[300],{9886:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>s,metadata:()=>r,toc:()=>h});var a=n(2322),o=n(5392);const s={slug:"why-json-schema",title:"Why JSON Schema?",authors:["fhur"],tags:["devlog"]},i="Why json-schema?",r={permalink:"/SynthQL/blog/why-json-schema",editUrl:"https://github.com/synthql/SynthQL/tree/master/packages/docs/blog/2024-05-10-why-json-schema/index.md",source:"@site/blog/2024-05-10-why-json-schema/index.md",title:"Why JSON Schema?",description:"I wanted to drop a few words on why we're chosing JSON schema as an intermediate representation for our schemas. Putting it in writing will make it clearer, so here goes.",date:"2024-05-10T00:00:00.000Z",formattedDate:"May 10, 2024",tags:[{label:"devlog",permalink:"/SynthQL/blog/tags/devlog"}],readingTime:2.655,hasTruncateMarker:!1,authors:[{name:"Fernando Hurtado",title:"SynthQL maintainer",url:"https://github.com/fhur",imageURL:"https://gravatar.com/fernandohur",key:"fhur"}],frontMatter:{slug:"why-json-schema",title:"Why JSON Schema?",authors:["fhur"],tags:["devlog"]},unlisted:!1},l={authorsImageUrls:[void 0]},h=[{value:"The goal: Static &amp; Runtime information about your schema",id:"the-goal-static--runtime-information-about-your-schema",level:2},{value:"Sub goal: select all fields",id:"sub-goal-select-all-fields",level:3},{value:"Sub goal: infer the groupingId",id:"sub-goal-infer-the-groupingid",level:3}];function c(e){const t={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",...(0,o.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(t.p,{children:["I wanted to drop a few words on why we're chosing ",(0,a.jsx)(t.code,{children:"JSON schema"})," as an intermediate representation for our schemas. Putting it in writing will make it clearer, so here goes."]}),"\n",(0,a.jsx)(t.h2,{id:"the-goal-static--runtime-information-about-your-schema",children:"The goal: Static & Runtime information about your schema"}),"\n",(0,a.jsx)(t.p,{children:"Let's start by asking ourselves what is the goal: the goal is to have schema information available to the query builder so you can build queries safely (no typos) and with great DX (auto completion)."}),"\n",(0,a.jsx)(t.p,{children:"To achieve this, the query builder needs to know the shape of your DB schema and convert it to something that the TypeScript compiler can understand."}),"\n",(0,a.jsx)(t.p,{children:"So we know that the query builder needs static type information. What's new is that the query builder also needs information at runtime about your schema. Let's look at a few examples that we want to support:"}),"\n",(0,a.jsx)(t.h3,{id:"sub-goal-select-all-fields",children:"Sub goal: select all fields"}),"\n",(0,a.jsx)(t.p,{children:"Let's look at a very basic example. Find an actor by ID."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-ts",children:"from('actors').where({ id: 1 }).maybe();\n"})}),"\n",(0,a.jsx)(t.p,{children:"We expect this to compile to something like"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-sql",children:"select actor_id, name, ...\nfrom actors\nwhere id = $1\n"})}),"\n",(0,a.jsxs)(t.p,{children:["Notice that I didn't write ",(0,a.jsx)(t.code,{children:"select *"}),'. That\'s intentional, because we can only select "selectable" fields. So the query builder needs to let the columns "default" to something like ',(0,a.jsx)(t.code,{children:"Object.keys(db.actors.columns)"}),". This is hint #1 that we need the schema available at runtime."]}),"\n",(0,a.jsx)(t.h3,{id:"sub-goal-infer-the-groupingid",children:"Sub goal: infer the groupingId"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-ts",children:"from('actor')\n  .where({id})\n  .include({ films })\n  .maybe()\n  .groupingId('actor_id') # <======= WHY DO I HAVE TO DO THIS?\n"})}),"\n",(0,a.jsx)(t.p,{children:"As you've already experienced the grouping ID is an annoyance. In most cases we can simply infer it: it's the primary key of the table. To actually infer it we need to have at runtime, type information available to the query builder so that the query builder can do something like"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-ts",children:"const groupingId = db.actor.primaryKey;\n"})}),"\n",(0,a.jsx)(t.p,{children:"Both of these sub-goals imply that in the near future the query builder will be passed not just the DB static type, but also some kind of runtime information about your schema."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-ts",children:"// old version: only has static type information available\nconst from = query<DB>().from;\n\n// new version: has both static and runtime type information available\nconst from = query<DB>(db).from;\n"})}),"\n",(0,a.jsx)(t.h1,{id:"so-why-json-schema",children:"So... why JSON schema?"}),"\n",(0,a.jsx)(t.p,{children:"Ok, now that we've talked about some of the goals we want to support: let's go back to the original question. Why is JSON schema a good choice?"}),"\n",(0,a.jsxs)(t.ol,{children:["\n",(0,a.jsx)(t.li,{children:"There is great tooling support for JSON schema: We can find libraries that generate zod from JSON schema or generate TypeScript types from json schema."}),"\n",(0,a.jsxs)(t.li,{children:["Building a JSON schema programmatically is really easy. Converting from ",(0,a.jsx)(t.code,{children:"pg-extract-schema"})," to JSON schema is trivial, and very easy to unit test."]}),"\n",(0,a.jsx)(t.li,{children:"JSON schema itself is available at runtime: As JSON schema is just a plain old javascript object, it's available at runtime, and so we can pass it to the query builer as input so it can use it to infer the groupingId and select all the fields."}),"\n",(0,a.jsxs)(t.li,{children:["Runtime type checking: In the future we will want to add something like zod to the ",(0,a.jsx)(t.code,{children:"QueryEngine"})," so that it blocks malformed queries. Using JSON Schema we can get zod for free."]}),"\n"]})]})}function d(e={}){const{wrapper:t}={...(0,o.a)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},5392:(e,t,n)=>{n.d(t,{Z:()=>r,a:()=>i});var a=n(2784);const o={},s=a.createContext(o);function i(e){const t=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),a.createElement(s.Provider,{value:t},e.children)}}}]);