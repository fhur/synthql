import { QueryEngine } from "..";
import { IntrospectSchemaConfig, PgSchema, TableDef, introspectSchema } from "./introspectSchema";
import fs from 'fs';

export interface GenerateSchemaConfig extends IntrospectSchemaConfig {
    out: string;
}

export async function generateSchema(queryEngine: QueryEngine<PgSchema>, config: GenerateSchemaConfig) {
    const schema = await introspectSchema(queryEngine, config);

    const str = `
// This file was generated by @synthql/backend
import { query } from "@synthql/queries"
export const db = {
${schema.tables.map(generateTable).join(",\n")}
} as const;

type AllNumberTypes = {
    schema: 'pg_catalog',
    name: 'int2' | 'int4' | 'numeric'
}

interface AllStringTypes {
    schema: 'pg_catalog',
    name: 'text' | 'varchar' | 'bpchar' | 'bytea' | 'bpchar' | 'uuid' | 'int8'
}

interface AllBoolTypes {
    schema: 'pg_catalog',
    name: 'bool'
}

interface AllDateTypes {
    schema: 'pg_catalog',
    name: 'date' | 'timestamptz'
}

type ConvertPgType<T> =
    T extends AllNumberTypes ? number
    : T extends AllStringTypes ? string
    : T extends AllBoolTypes ? boolean
    : T extends AllDateTypes ? Date
    : [unknown, T]

type InferColumn<T> =
    // Nullable check
    T extends { nullable: true, type: infer Type } ? null | ConvertPgType<Type> :
    T extends { type: infer Type } ? ConvertPgType<Type> : never

type InferTable<T> =
    T extends { columns: infer C } ? { [column in keyof C]: InferColumn<C[column]> } : never

type InferDB<T> = {
    [table in keyof T]: InferTable<T[table]>
}

export type DB = InferDB<typeof db>
export const from = query<DB>().from;
`
    fs.writeFileSync(config.out, str)
}

function generateTable(table: TableDef): string {
    return `    '${table.name}': ${JSON.stringify(table, null, 4)}`
}